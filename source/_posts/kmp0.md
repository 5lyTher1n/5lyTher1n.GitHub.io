---
title: KMP算法学习笔记
date: 2019-09-18 09:09:24
tags: algorithms	
categories: algorithms
---
# 前情摘要 #

其实，KMP不是第一次学了，但是总是学了忘忘了学，原因还是以前只是记住了用法和板子，但是对于整个算法的理解很不到位，恰巧这次做康复训练时首先看到了KMP，就决定先认真学下这个吧~ 

**友情提醒：**

**本人表达能力欠缺。文章看起来可能有点别扭，望见谅，实在难受可右上角。**

**尽量以后写好点吧 0.0**

# 字符串匹配问题 #

在一个主串S内查找一个模式串W的出现位置。面对这样的问题，我们该怎么解决呢？顺着最初的解决方法往下逐步引入KMP。
##  暴力枚举 ##
最初的想法是暴力，因为，这是最简单最容易想到的方法。枚举S的每个位置i，同时使j以i为起始点，对比W的每个位置k，判断S[j]是否与W[k]相等，相等则当前i为答案。

这种解决方法简单暴力，但是时间复杂度可以达到O(len(S) * len(W))当两个字符串长度乘积较大时会耗时特别长。那么现在考虑优化。

##  优化一 ##
对于这个问题，我最开始想到的优化方法是，如果能够匹配成功，则主串开始位置字符与模式串首位字符一定相等(即s[i] == w[0])，所以，首先先对主串枚举寻找等于W[0]的位置，将其放入一个list中。然后以list的元素为起始点，开始进行匹配工作。

时间复杂度大概为O( num[ w[0] ] * len(W) )，看起来***像***是优化的不错，但是很容易发现，这种优化很容易因为S中w[0]数量过多而退化，形如S="aafaabc",W="abc"时，并没有优化多少。

<!--more-->

##  优化二 ##

还有一种优化方式是在网上看到的，即当前匹配失败时，跳过匹配成功的地方，直接在失败开始匹配。额，这种优化我没想到过，因为，很容易找到反例进行Challenge.

*(PS:我想到的这种优化的反例是，S="abcabcabd" W="abcabd")*

*(todo:好像能总结出方法，但是，叙述不好，之后再做0.0)*

#  KMP #
在1.3种提到的优化，那个跳跃式的方法很有趣，只是跳跃的太多了，容易把正确解跳过。而1.2所示的优化方法可以看做跳跃太少，那么怎么才能跳跃到刚刚好的位置？同时，尽可能利用已经匹配过的结果，将乘法复杂度优化成加法复杂度。

这时看到了KMP算法。

对于S="abcabcabd",W="abcabd"来说。
> 0 1 2 3 4 5 6 7 8
> 
> a b c a b c a b d
> 
> a b c a b d


匹配到i=5时，一个是c一个是d。可以发现，当前已经匹配完成的S'="abcab"与W'="abcab"是相等的，只要找到前缀后缀最长匹配表，就是下一次开始查找的位置。这里最长的前后缀匹配表是"ab"，那么现在第一个"ab"不对，只要跳跃到第二个"ab"上就可以了。

# 部分匹配表 #
因为最终需要查找的是主串中的模式串，可以提前预处理出模式串的最长前后缀表。

怎么处理好呢？

举例来说，W = " a b a b a b z a b a b a b a"

w[i] | a | b | a | b | a | b | z | a | b | a | b  | a  | b  | a 
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
i    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 
x[i] | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 5 



1. 首先初始化，i = j = 0; 
2. i=1时,x[i]依然为0
3. i=2时，对比出w[i] == w[j] == 'a',所以x[i] = 1,同时j到下一位，j=1；
4. i=3时，对比出w[i] == w[j] == 'b',这时，最长匹配串为"ab"，所以x[i] = 2,j=2.
5. i=4时，对比出w[i] == w[j] == 'a',这时，最长匹配串为"aba"，所以x[i] = 3,j=3.

到这里不难发现，也很好理解，当w[i] == w[j]时 x[i] == x[i-1] + 1；后面的结果也能证实公式的正确性。

直到当i=6，j=4.先直接目测，就可以看出来此时x[i] = 0；一直到i=13，j=6.w[i]='a'但是，w[j]='z'.两者不相等。

这里可以看作：

将Q="ababab",则W=Q+z+Q+'a'。

怎么寻找新的最长前后缀串呢?
首先新的前后缀串Q'长度必然不会大于Q的长度*(如果Q="aaaaaa"，即Q中每个字符相等且等于新加入的字符时，len(Q') == len(Q) )*

我们可以把这个新问题当成一个子问题，此时W=Q\*+ t + H + Q\* + 'a'.这里的H是一个长度大于等于
z的一个字符串，t是衔接Q\*与H的一个字符。

如果t == 'a',则可以确定新的最大前后缀串是Q\*+t或者也可以说是Q\*+'a'

如果t != 'a'怎么办呢？继续往下划分啊。。。不断缩小Q\*的长度。

那么问题又来了，怎么找到第一个Q\*，即长度最长的Q\*。

这里可以用次长前后缀串，也就是长度仅次于最长前后缀串的串0.0

那么次长前后缀串怎么找呢？可以看如图所示。（ ~~忽略灵魂画手~~ ）
![次长前后缀串示意图](https://i.loli.net/2019/09/18/768hTNZSy4vfCcX.jpg)

黑色是最长前后缀串，蓝色是次长前后缀串，因为同色是对应相等的，所以可以把后边的蓝色移动到前边，可以发现，次长前后缀串就是最长前后缀串的最长前后缀串0.0（ ~~我这表达能力我也是服了~~ ）

所以，回到表中。w[13] == w[ x[x[12]-1]]，所以x[13] = x[5] + 1 = 5。 
用这种方法可以回过来证明x[6] = 0.

# 算法实现 #

首先看上边的公式也能发现，对于位置i，我们只考虑i-1的前后缀串情况。我们可以用一个数组表示x[i]右移一位的结果，这样更方便。这个也就是平时所说的next数组。


    void getNext(char * w, long * next)
    {
    	next[0] = -1;
    	long i = 0, j = -1;
    
    	while (i < strlen(w))
    	{
    		if (j == -1 || w[i] == w[j])
    		{
    			++i;
    			++j;
    			next[i] = j;
    		}	
    		else
    			j = next[j];
    	}
    }

之后是使用next的KMP算法
	
	int KMP(char * t, char * p) 
	{
		int i = 0; 
		int j = 0;
	
		while (i < strlen(t) && j < strlen(p))
		{
			if (j == -1 || t[i] == p[j]) 
			{
				i++;
	           	j++;
			}
		 	else 
	           		j = next[j];
	    }
	
	    if (j == strlen(p))
	       return i - j;
	    else 
	       return -1;
	}





> 参考链接：
> 
> https://www.zhihu.com/question/21923021/answer/37475572
> https://www.zhihu.com/question/21923021/answer/281346746
> http://aaaron7.github.io/blog/algorithm/kmp-explain


# 写在最后 #
哇，写博客可太难了。尤其是我这表达能力，写的可太费劲了。如果看了这篇blog求不打我。

也觉得，通过把想的转化成写的，会把思路理清 ~~ (尽管不一定能写清0.0 ) ~~

中间有些不清楚的细节也可以想清楚。

只是这个表达和文章格式真的有点一言难尽，我觉得把我想写的不想写的都写了出来，有点抓不住重点，可能太想都兼顾反而什么都没有说清。

以后慢慢来吧，看别人文章时多留意，慢慢写慢慢改吧~ 

有机会，可能的话，把这篇文章再重构下吧。。。

加油~~~



 




